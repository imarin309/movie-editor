# CLAUDE.md

このファイルは、このリポジトリで作業する際にClaude Code (claude.ai/code) へのガイダンスを提供します。

## プロジェクト概要

プラモデルや工作動画を自動処理するためのPythonベースの動画編集ツールです。MediaPipeを使用して手の動きを検出し、実際の作業が映っている部分のみを残すように動画をクロップ/カットします。長時間の工作動画から不要なフレームを削除し、編集を簡単にします。

**ユースケース**: プラモデル制作動画を編集する際に、手が映っていない退屈な部分を自動的にカットします。

## セットアップと開発

### インストール

```bash
poetry install
```

### ツールの実行

```bash
poetry run python command.py {input_movie_path}
```

出力ファイルは自動的に `{input_movie_path}_edited.{拡張子}` として生成されます（例: `video.mp4` → `video_edited.mp4`）。

### 設定

すべての処理パラメータは `config.py` で定義されています：

**MediaPipe手検出の設定:**
- `DEFAULT_FPS_SAMPLE`: 解析時のサンプリングFPS (デフォルト: 15)
- `DEFAULT_MIN_CONFIDENCE`: MediaPipeの最小信頼度 0-1 (デフォルト: 0.5)
- `DEFAULT_MIN_AREA_RATIO`: 最小の手のバウンディングボックス面積 / フレーム面積 (デフォルト: 0.003 = 0.3%)

**セグメント処理の設定:**
- `DEFAULT_MIN_KEEP_SEC`: この秒数より短いセグメントを除外 (デフォルト: 1.0)
- `DEFAULT_MERGE_GAP_SEC`: 小さな隙間で区切られたセグメントを結合する秒数 (デフォルト: 0.25)
- `DEFAULT_PAD_SEC`: 各セグメントの前後に追加するパディング秒数 (デフォルト: 0.3)

**クロップ位置の設定:**
- `DEFAULT_CROP_HAND_HORIZONTAL_RATIO`: 手を画面の左から何%の位置に配置するか (デフォルト: 0.7 = 右寄り、0.5 = 中央)
- `DEFAULT_CROP_HAND_VERTICAL_RATIO`: 手を画面の上から何%の位置に配置するか (デフォルト: 0.5 = 中央)
- `DEFAULT_SMOOTH_WINDOW_SIZE`: 手の位置スムージングの移動平均ウィンドウサイズ (デフォルト: 7)

パラメータを変更したい場合は、`config.py` を直接編集してください。

### コード品質ツール

```bash
# blackでコードをフォーマット
poetry run black .

# importsをソート
poetry run isort .

# flake8でリント
poetry run flake8 .

# mypyで型チェック
poetry run mypy .
```

## アーキテクチャ

動画処理パイプラインは、`src/edit_movie.py`の`EditMovie`クラスによって調整される4つの主要なステージで構成されています:

### 1. 手の検出 (`src/service/masking/hand.py`)

- **`detect_hands_mask()`**: MediaPipeを使用してフレームごとに手を検出し、ブール値マスクを返す
  - 指定されたFPSで動画をサンプリング（パフォーマンスのためのダウンサンプリング）
  - 信頼度閾値と最小バウンディングボックス面積比で検出をフィルタリング

- **`detect_hands_position()`**: クロップ用に手の中心座標を検出
  - フレームごとに正規化された(0.0-1.0)手の中心座標を返す
  - 手が検出されないフレームには`None`を返す

- **`smooth_positions()`**: 手の位置に移動平均スムージングを適用
  - クロップ出力でのカメラの揺れを防止

### 2. セグメント生成 (`src/service/segment/main.py`)

- **`bools_to_segments()`**: ブール値マスクを時間セグメント(開始/終了秒数)に変換
  - `min_keep_sec`より短いセグメントをフィルタリング
  - `merge_gap_sec`より小さい隙間で区切られたセグメントを結合
  - 各セグメントの前後にパディング(`pad_sec`)を追加

- **`clamp_segments()`**: セグメントが動画の長さを超えないようにする

### 3. 動画のクロップ (`src/service/crop/cropping.py`)

- **`crop_to_hand_center()`**: 検出された手を中心にクロップ
  - 手をフレーム内の右寄り（左から70%の位置）に配置
  - 手が検出されたフレームのみを含める
  - クロップされたセグメントを連結して最終出力を生成

### 4. 動画の組み立て (`src/edit_movie.py`)

- **`EditMovie.run()`**: メインのオーケストレーションメソッド
  - 現在の実装はクロップに焦点を当てている（コメントアウトされた行は代替のセグメントベースのカットを示す）
  - 処理されたクリップを組み立て、moviepyを使用してエクスポート
  - リソースのクリーンアップを処理（VideoFileClipのclose）

### 処理モード (`EditMovie.run()`で設定可能)

コードベースは`run()`内のコメント行によって2つの処理モードをサポートしています:

**現在のモード（クロップ）**:

- 手の位置を検出
- 手を中心にフレームをクロップ
- 手が見えるフレームのみを保持

**代替モード（セグメントカット）**:

- 手の存在のブール値マスクを生成
- 手の活動の時間セグメントを作成
- それらのセグメントのみをカットして連結
- オプションで速度倍率を適用

## 主要な実装の詳細

### MediaPipeによる手の検出

- 設定可能な信頼度閾値で`mp.solutions.hands`を使用
- RGBフレームを処理（BGRから変換）
- 手のランドマーク（1つの手につき21ポイント）からバウンディングボックスを計算
- 最大2つの手を同時にサポート

### MoviePyによる動画処理

- 入出力に`VideoFileClip`を使用
- `subclipped()`で時間セグメントを抽出
- `concatenate_videoclips()`で`method="compose"`を使用して最終組み立て
- H.264コーデックとAACオーディオでエクスポート

### パフォーマンス最適化

- フレームサンプリング: `fps_sample`に基づいてN番目のフレームを解析
- 実効FPS計算: `eff_fps = orig_fps / step`
- 手の検出中に`tqdm`で進捗追跡

## 重要な注意事項

- 動画処理パイプラインを変更する際は、適切なリソースクリーンアップを確認してください（クリップで`.close()`を呼び出す）
- マスキングアプローチは元の動画のFPSではなく、サンプリングFPSでマスクを返します
- 手の検出は最大限の柔軟性のためフルフレームを使用します（ROIなし）
- バウンディングボックス面積比は小さな誤検出からのノイズを防ぎます

## コーディング規約

- print文ではなくloggerを使用してください。
- 変数や戻り値には必ず型アノテーションを付与してください。
- 日本語でコメントを書く際は文字コードを「utf-8」にするようにしてください。
- コメントについて
  - 関数名で処理内容が自明なものはDocstringは記載しないでください。
  - できるだけ変数名や関数名で処理がわかるようにして、処理内容のコメントは省いてください。処理内容から実装の背景がわからないものについてコメントを記載するようにしてください。
- 依存関係を次のようにしてください
  - command.py -> edit_movie.py -> service/ -> model/

## その他

- ユーザーと対話する時は「いまりん」と呼んで下さい。
